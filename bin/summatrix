#!/usr/bin/env summon
#
# SUMMATRIX (SUMMON Sparse Matrix Viewer)
#
# Example of using summon to visualize large sparse matrices.
#
# Example matrices are in summon/examples/summatrix/
# Matrix file formats:
#   *.mat   compress row (-r option)
#   *.imat  index matrix (-i option)
#   *.lmat  label matrix 
#

# TODO: implement find, and marking


import random
import sys

from summon.core import *
from summon import *
from summon import shapes, util, plotting

# command line options
options = [
    "matrix formats",
    ["r:", "comprow=", "comprow", "<compressed row matrix file>",
        {"single": True}],
    ["i:", "imat=", "imat", "<index matrix file>",
        {"single": True}],
    ["l:", "lmat=", "lmat", "<labeled sparse matrix file>",
        {"single": True}],
    ["d:", "dense=", "dense", "<dense matrix file>",
        {"single": True}],
    
    "labels",
    ["", "rlab=", "rowlabels", "<row labels>",
        {"single": True}],
    ["", "clab=", "collabels", "<col labels>", 
        {"single": True}],    
    ["", "rclab=", "rowcollabels", "<row & col labels>", 
        {"single": True}],
    
    "permutation",
    ["R:", "rperm=", "rperm", "<row permutation>",
        {"single": True}],
    ["C:", "cperm=", "cperm", "<col permutation>",
        {"single": True}],
    ["B:", "rcperm=", "rcperm", "<row & col permutation>",
        {"single": True}],

    ["o:", "order=", "order", "<label order>",
        {"single": True}],
    
    "clustering",
    ["", "rpart=", "rpart", "<row partition ids>",
        {"single": True}],
    ["", "cpart=", "cpart", "<col partition ids>",
        {"single": True}],
    ["", "rcpart=", "rcpart", "<row & col partition ids>",
        {"single": True}],

    
    "misc",
    ["s:", "sample=", "sample", "<sample fraction>",
        {"single": True,
         "parser": float}],
    ["c:", "color=", "color", "(solid|posneg|rainbow|filename)",
        {"single": True,
         "default": "solid"}],
    ["", "cutoff=", "cutoff", "<value>",
        {"default": -1e1000,
         "parser": float,
         "single": True}]
]


param = util.parseOptions(sys.argv[1:], options, resthelp="<python script>")



#############################################################################
# Data Structures
#

class RainbowColorMap:
    def __init__(self, maxv=1.0, minv=0.0):
        self.max = maxv
        self.min = minv
        self.range = maxv - minv
    
    def get(self, val):
        x = (val - self.min) / self.range
        return [-2 + 4*x, 2 - 4*abs(.5-x), 2 - 4*x]
    

class PosNegColorMap:
    def __init__(self, minv=-1.0, maxv=1.0):
        self.max = maxv
        self.min = minv
    
    def get(self, val):
        if val >= 0:
            return [1, 0, 0, val/self.max]
        else:
            return [0, 1, 0, val/self.min]

class SolidColorMap:
    def __init__(self, maxv=1.0, minv=0.0):
        self.max = maxv
        self.min = minv
        self.range = maxv - minv
    
    def get(self, val):
        return [1, 1, 1]


class Matrix (util.Dict):
    def __init__(self):
        util.Dict.__init__(self, 2, 0)
        self.nrows = 0
        self.ncols = 0
        self.nnz   = 0
        
        self.order = None
        self.maxval = None
        self.minval = None
        
        self.rowlabels = None
        self.collabels = None
        
        self.rperm = []
        self.cperm = []
        self.rinv  = []
        self.cinv  = []
        
        self.rpart = None
        self.cpart = None
        
        self.colormap = PosNegColorMap()
        self.rows = []
        self.cols = []
        self.vals = []
            
    
    def setup(self, nrows, ncols, nnz):
        self.nrows = nrows
        self.ncols = ncols
        self.nnz   = nnz        

        if self.rperm == []:
            self.rperm[:] = range(nrows)
        if self.cperm == []:
            self.cperm[:] = range(ncols)

        self.rinv[:] = util.invPerm(self.rperm)
        self.cinv[:] = util.invPerm(self.cperm)

    def setColor(colormap, low, top):
        self.colormin = float(low)
        self.colormax = float(top)
        self.colorrange = float(top - low)
        self.colormap = colormap
        self.colorlen = colorlen
        

    def getColor(self, val):
        i = int((val - self.colormin) / self.colorrange)
        i = min(max(i, 0), self.colorlen)
        return self.colormap[i]


#############################################################################
# Matrix Reading
#



def readColorMap(filename):
    mat = []

    for line in file(filename):
        value, red, green, blue = map(float, line.rstrip().split())
        mat.append([value, [red, green, blue, 1.0]])
        
    try:
        return plotting.ColorMap(mat)
    except:
        print "error readin colormap, using default"
        return RainbowColorMap()
        


def openCompRow(filename, mat):
    util.tic("reading '%s'" % filename)
    infile = file(filename)
    
    # read header
    fields = infile.next().split()
    if len(fields) == 2:
        (nrows, nnz) = map(int, fields)
        ncols = nrows
    elif len(fields) == 3:
        (nrows, ncols, nnz) = map(int, fields)
    else:
        raise "expected (nrows, nnz) or (nrows, ncols, nnz) in first line"
    
    
    util.log("%s: %d nrows, %d ncols, %d non-zeros" % (filename, nrows, ncols, nnz))
    
    mat.setup(nrows, ncols, nnz)
    rows, cols, vals = (mat.rows, mat.cols, mat.vals)
        
    row = 0
    maxval = -1e1000
    minval = 1e1000
    for line in infile:
        fields = line.split()

        if "sample" in param and random.random() > param["sample"]:
            row += 1
            continue

        for i in xrange(0, len(fields), 2):
            col = int(fields[i]) - 1
            val = float(fields[i+1])
            rows.append(row)
            cols.append(col)
            vals.append(val)
            if val > maxval: maxval = val
            if val < minval: minval = val
        row += 1
    util.toc()
    
    mat.maxval = maxval
    mat.minval = minval
    
    return mat


def openImat(filename, mat):
    util.tic("reading '%s'" % filename)
    infile = file(filename)
    
    # read header
    (nrows, ncols, nnz) = map(int, infile.next().split())
    print "%s: %d nrows, %d ncols, %d non-zeros" % (filename, nrows, ncols, nnz)        
    
    mat.setup(nrows, ncols, nnz)
    rows, cols, vals = (mat.rows, mat.cols, mat.vals)
    
    i = 0
    maxval = -1e1000
    minval = 1e1000
    for line in infile:
        if "sample" in param and random.random() > param["sample"]:
            continue
        
        (row, col, val) = line.split()
        score = float(val)
        rows.append(int(row))
        cols.append(int(col))
        vals.append(score)
        if score > maxval: maxval = score
        if score < minval: minval = score
    util.toc()
    
    mat.maxval = maxval
    mat.minval = minval
    
    return mat



def openLabeledMatrix(filename, mat):
    util.tic("reading '%s'" % filename)
    
    # read all data
    nnz = 0
    maxval = -1e1000
    minval = 1e1000
    for line in file(filename):
        tokens = line.split()
        score = float(tokens[2])
        mat[tokens[0]][tokens[1]] = score
        if score > maxval: maxval = score
        if score < minval: minval = score
        nnz += 1
    
    mat.maxval = maxval
    mat.minval = minval
    
    # determine order
    if mat.order != None:
        labels = util.readStrings(mat.order)
    else:
        set = {}
        for i in mat:
            set[i] = 1
            for j in mat[i]:
                set[j] = 1
        labels = util.unique(set.keys())
        labels.sort()
    lookup = util.list2lookup(labels)
    
    mat.setup(len(labels), len(labels), nnz)
    rows, cols, vals = (mat.rows, mat.cols, mat.vals)
    
    # store data
    for i in mat:
        for j in mat[i]:
            rows.append(lookup[i])
            cols.append(lookup[j])
            vals.append(mat[i][j])
    
    util.toc()
    
    return mat
    


def openDense(filename, mat):
    util.tic("reading '%s'" % filename)
    infile = file(filename)
    
    # read header
    (nrows, ncols) = map(int, infile.next().split())
    nnz = nrows * ncols
    util.log("%s: %d nrows, %d ncols, %d non-zeros" % (filename, nrows, ncols, nnz))
    
    mat.setup(nrows, ncols, nnz)
    rows, cols, vals = (mat.rows, mat.cols, mat.vals)
    
    cutoff = param['cutoff']
    
    # read in whole matrix
    maxval = -1e1000
    minval = 1e1000
    r = 0
    
    for line in infile:
        entries = map(float, line.split())
        for c in xrange(len(entries)):
            if entries[c] >= cutoff:
                rows.append(r)
                cols.append(c)
                vals.append(entries[c])
                if entries[c] > maxval: maxval = entries[c]
                if entries[c] < minval: minval = entries[c]
                mat[r][c] = entries[c]
        r += 1
    
    mat.maxval = maxval
    mat.minval = minval
        
    util.toc()
    return mat



#######################################################################
# Drawing
#

def mouseClick():
    x, y = get_mouse_pos('world')
    x = int(x+.5)
    y = -int(y-.5)
    
    x = mat.cperm[x]
    y = mat.rperm[y]
    
    if mat.rowlabels != None:
        row = mat.rowlabels[y]
    else:
        row = y
    if mat.collabels != None:
        col = mat.collabels[x]
    else:
        col = x
    
    print row, col, "mat[%d][%d] = %f" % (y, x, mat[y][x])
    

def drawBorder(nrows, ncols):
    # draw boundary 
    add_group(group(color(1,1,1), 
              shapes.boxStroke(-.5,.5,ncols-.5, -nrows+.5)))

def drawPartitions(mat):
    vis = [color(1,1,1)]
    
    # draw row partitions
    if mat.rpart != None:
        part = -1
        for i in xrange(mat.nrows):
            if mat.rpart[mat.rperm[i]] != part:
                vis.append(lines(-.5, -i+.5, mat.ncols, -i+.5))
                part = mat.rpart[mat.rperm[i]]
    
    # draw col partitions
    if mat.cpart != None:
        part = -1
        for i in xrange(mat.ncols):
            if mat.cpart[mat.cperm[i]] != part:
                vis.append(lines(i-.5, .5, i-.5, -mat.nrows+.5))
                part = mat.cpart[mat.cperm[i]]
    
    add_group(group(* vis))
    
    
def drawMatrix(mat):
    util.tic("drawing matrix")
    mat.colormap.max = mat.maxval
    mat.colormap.min = mat.minval
    mat.colormap.range = mat.maxval - mat.minval
    getcolor = mat.colormap.get
    vis = []
    chunksize = 1000
    rows, cols, vals = (mat.rows, mat.cols, mat.vals)
    rinv, cinv = (mat.rinv, mat.cinv)
    
    for chunk in xrange(0, len(rows), chunksize):
        if param["color"] == "solid":
            for k in xrange(chunk, min(len(rows), chunk+chunksize)):
                vis.append(cinv[cols[k]])
                vis.append(-rinv[rows[k]])
        else:
            for k in xrange(chunk, min(len(rows), chunk+chunksize)):
                vis.append(color(* getcolor(vals[k])))
                vis.append(cinv[cols[k]])
                vis.append(-rinv[rows[k]])
        add_group(group(points(* vis)))
        vis = []
    
    add_group(group(hotspot('click', -.5, .5, mat.ncols-.5, -mat.nrows+.5, mouseClick)))
    
    
    # draw extra
    drawBorder(mat.nrows, mat.ncols)
    drawPartitions(mat)
    
    util.toc()
    

def one2one():
    """Make zoom one2one"""
    
    x, y, x2, y2 = get_visible()
    vwidth = x2 - x
    vheight = y2 - y
    width, height = get_window_size()
    
    zx = width / vwidth
    zy = height / vheight
    
    if zx > zy:
        zoomy(zx / zy)
    else:
        zoomx(zy / zx)



#######################################################################
# Main Execution
#

print "SUMMATRIX (SUMMON Matrix Visualizer)"
print "Matt Rasmussen 2005"
print

set_antialias(False)
mat = Matrix()
set_binding(input_key("1"), one2one)

# read permutations
if "rperm" in param:
    mat.rperm = util.readInts(param["rperm"])
elif "cperm" in param:
    mat.cperm = util.readInts(param["cperm"])
elif "rcperm" in param:
    mat.rperm = util.readInts(param["rcperm"])        
    mat.cperm = util.readInts(param["rcperm"])

# read color
if param["color"] == "posneg":
    mat.colormap = PosNegColorMap()
elif param["color"] == "rainbow":
    mat.colormap = RainbowColorMap()
elif param["color"] == "solid":
    mat.colormap = SolidColorMap()
else:
    mat.colormap = readColorMap(param["color"])


if "order" in param:
    mat.order = param["order"]

# read matrix
if "comprow" in param:
    openCompRow(param["comprow"], mat)
elif "imat" in param:
    openImat(param["imat"], mat)
elif "lmat" in param:
    if "order" in param:
        openLabeledMatrix(param["lmat"], mat)
    else:
        openLabeledMatrix(param["lmat"], mat)
elif "dense" in param:
    openDense(param["dense"], mat)
else:
    raise "no matrix specified"


# read labels
if "rowlabels" in param:
    mat.rowlabels = util.readStrings(param["rowlabels"])
if "collabels" in param:
    mat.collabels = util.readStrings(param["collabels"])
if "rowcollabels" in param:
    mat.rowlabels = util.readStrings(param["rowcollabels"])
    mat.collabels = mat.rowlabels


# read partitions
if "rpart" in param:
    mat.rpart = util.readStrings(param["rpart"])
if "cpart" in param:
    mat.cpart = util.readStrings(param["cpart"])
if "rcpart" in param:
    mat.rpart = util.readStrings(param["rcpart"])
    mat.cpart = mat.rpart 


# execute python script
for script in param["REST"]:
    print "executing", script
    execfile(script)



drawMatrix(mat)
home()


