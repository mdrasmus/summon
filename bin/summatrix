#!/usr/bin/env summon

import random
import sys

from summon import *
from summonlib import shapes, util

# command line options
options = [
    ["a:", "adj=", "adj", "AUTO<adjacency matrix file>"],
    ["i:", "imat=", "imat", "AUTO<index matrix file>"],
    ["l:", "lmat=", "lmat", "AUTO<labeled sparse matrix file>"],
    ["o:", "order=", "order", "AUTO<label order>"],
    ["d:", "dense=", "dense", "AUTO<dense matrix file>"],
    
    ["R:", "rperm=", "rperm", "AUTO<row permutation>"],
    ["C:", "cperm=", "cperm", "AUTO<col permutation>"],
    ["B:", "rcperm=", "rcperm", "AUTO<row & col permutation>"],
   
    ["s:", "sample=", "sample", "AUTO<sample fraction>"],
    ["c", "color", "color", ""]
]

try:
    param, rest = util.parseArgs(sys.argv[1:], options, "files")
except:
    sys.exit(1)




class ColorMap:
    def __init__(self, maxv=1.0, minv=0.0):
        self.colors = [[1,0,0,0], 
                       [1,0,0,1]] 
        self.max = maxv
        self.min = minv
        self.range = maxv - minv
    
    def get(self, val):
        mix1 = (val - self.min) / self.range
        mix2 = 1 - mix1
        c1 = self.colors[0]
        c2 = self.colors[1]
        return [mix1 * c1[0] + mix2 * c2[0],
                mix1 * c1[1] + mix2 * c2[1],
                mix1 * c1[2] + mix2 * c2[2],
                mix1 * c1[3] + mix2 * c2[3]]
    

class PosNegColorMap:
    def __init__(self, minv=-1.0, maxv=1.0):
        self.max = maxv
        self.min = minv
    
    def get(self, val):
        if val > 0:
            return [1, 0, 0, val/self.max]
        else:
            return [0, 1, 0, val/self.min]


class Matrix (util.Dict):
    def __init__(self):
        util.Dict.__init__(self, 2, 0)
        self.nrows = 0
        self.ncols = 0
        self.nnz   = 0
        
        self.rperm = []
        self.cperm = []
        self.rinv  = []
        self.cinv  = []
        
        self.colormap = PosNegColorMap()
        
    
    def setup(self, nrows, ncols, nnz):
        self.nrows = nrows
        self.ncols = ncols
        self.nnz   = nnz        

        if self.rperm == []:
            self.rperm[:] = range(nrows)
        if self.cperm == []:
            self.cperm[:] = range(ncols)

        self.rinv[:] = util.invPerm(self.rperm)
        self.cinv[:] = util.invPerm(self.cperm)

    def setColor(colormap, low, top):
        self.colormin = float(low)
        self.colormax = float(top)
        self.colorrange = float(top - low)
        self.colormap = colormap
        self.colorlen = colorlen
        

    def getColor(self, val):
        i = int((val - self.colormin) / self.colorrange)
        i = min(max(i, 0), self.colorlen)
        return self.colormap[i]


#############################################################################
# Matrix Reading
#



def openAdj(filename):
    util.tic("reading '%s'" % filename)
    mat = Matrix()
    infile = file(filename)
    
    # read header
    fields = infile.next().split()
    if len(fields) == 2:
        (nrows, nnz) = map(int, fields)
        ncols = nrows
    elif len(fields) == 3:
        (nrows, ncols, nnz) = map(int, fields)
    else:
        raise "expected (nrows, nnz) or (nrows, ncols, nnz) in first line"
    
    
    util.log("%s: %d nrows, %d ncols, %d non-zeros" % (filename, nrows, ncols, nnz))
    
    mat.setup(nrows, ncols, nnz)
    
    dots  = []
    row = 0
    for line in infile:
        fields = line.split()

        if "sample" in param and random.random() > param["sample"]:
            row += 1
            continue

        for i in xrange(0, len(fields), 2):
            col = int(fields[i]) - 1
            val = float(fields[i])
            dots.append(mat.cinv[col])
            dots.append(mat.rinv[row])
        row += 1
        
        if len(dots) > 100000:
            add_group(group(color(1,0,0), points(apply(vertices, dots))))
            dots = []
    add_group(group(color(1,0,0), points(* dots)))
    
    util.toc()
    
    return mat


def openImat(filename):
    util.tic("reading '%s'" % filename)
    mat = Matrix()
    infile = file(filename)
    
    # read header
    (nrows, ncols, nnz) = map(int, infile.next().split())
    print "%s: %d nrows, %d ncols, %d non-zeros" % (filename, nrows, ncols, nnz)        
    
    mat.setup(nrows, ncols, nnz)
    
    dots = [0] * (3 * nnz)
    mat.clear()
    getcolor = mat.colormap.get
    cinv = mat.cinv
    rinv = mat.rinv
    i = 0
    for line in infile:
        if "sample" in param and random.random() > param["sample"]:
            continue
        (row, col, val) = line.split()
        r = int(row)
        c = int(col)
        dots.append(color(* getcolor(float(val))))
        dots.append(mat.cinv[c])
        dots.append(mat.rinv[r])
        i += 3
    
    # draw remaining points
    add_group(group(color(1,0,0), points(* dots)))
    
    util.toc()
    
    return mat



def openLabeledMatrix(filename, order = None):
    util.tic("reading '%s'" % filename)
    mat = Matrix()    
    
    maxval = -1e1000
    minval = 1e1000
    
    # read all data
    nnz = 0
    for line in file(filename):
        tokens = line.split()
        score = float(tokens[2])
        mat[tokens[0]][tokens[1]] = score
        maxval = max(maxval, score)
        minval = min(maxval, score)
        nnz += 1
    
    # determine order
    if order != None:
        labels = util.readStrings(order)
    else:
        set = {}
        for i in mat:
            set[i] = 1
            for j in mat[i]:
                set[j] = 1
        labels = util.uniq(set.keys())
        labels.sort()
    lookup = util.list2lookup(labels)
    
    mat.setup(len(labels), len(labels), nnz)
    
    # draw matrix
    vis = []
    for i in mat:
        for j in mat[i]:
            if mat[i][j] >= 0:
                vis.append(color(1, 0, 0, mat[i][j] / maxval))
            else:
                vis.append(color(0, 1, 0, mat[i][j] / minval))
            vis.append(vertices(lookup[j], lookup[i]))
        if len(vis) > 10000:
            add_group(group(apply(points, vis)))
            vis = []
    add_group(group(apply(points, vis)))
    
    util.toc()
    
    return mat
    


def openDense(filename):
    util.tic("reading '%s'" % filename)
    mat = Matrix()
    infile = file(filename)
    
    # read header
    (nrows, ncols) = map(int, infile.next().split())
    nnz = nrows * ncols
    util.log("%s: %d nrows, %d ncols, %d non-zeros" % (filename, nrows, ncols, nnz))
    
    mat.setup(nrows, ncols, nnz)
    
    
    # read in whole matrix
    maxval = -1e1000
    minval = 1e1000
    r = 0
    for line in infile:
        vals = map(float, line.split())
        for c in xrange(len(vals)):
            mat[r][c] = vals[c]
            maxval = max(maxval, vals[c])
            minval = min(minval, vals[c])
        r += 1
    
    
    # draw matrix
    vis = []
    for i in xrange(nrows):
        for j in xrange(ncols):
            if mat[i][j] >= 0:
                vis.append(color(mat[i][j] / maxval, 0, 0))
            else:
                vis.append(color(0, mat[i][j] / minval, 0))
            vis.append(vertices(mat.cinv[j], mat.rinv[i]))
        if len(vis) > 10000:
            add_group(group(apply(points, vis)))
            vis = []
    add_group(group(apply(points, vis)))
    
    util.toc()
    return mat
    


#######################################################################
# Drawing
#

def drawBorder(nrows, ncols):
    # draw boundary 
    add_group(group(color(1,1,1), 
              shapes.boxStroke(-.5,-.5,ncols-.5, nrows-.5)))
    


#######################################################################
# Main Execution
#

print "SUMMATRIX (SUMMON Matrix Visualizer)"
print "Matt Rasmussen 2005"
print


set_antialias(False)

# read permutations
if "rperm" in param:
    rperm[:] = util.readInts(param["rperm"][-1])
elif "cperm" in param:
    cperm[:] = util.readInts(param["cperm"][-1])
elif "rcperm" in param:
    rperm[:] = util.readInts(param["rcperm"][-1])        
    cperm[:] = util.readInts(param["rcperm"][-1])


# read matrix
if "adj" in param:
    mat = openAdj(param["adj"][-1])
elif "imat" in param:
    mat = openImat(param["imat"][-1])
elif "lmat" in param:
    if "order" in param:
        mat = openLabeledMatrix(param["lmat"][-1], param["order"][-1])
    else:
        mat = openLabeledMatrix(param["lmat"][-1])
elif "dense" in param:
    mat = openDense(param["dense"][-1])    
else:
    raise "no matrix specified"

        
drawBorder(mat.nrows, mat.ncols)
home()


