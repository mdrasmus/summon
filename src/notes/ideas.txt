=============================================================================
Thu Sep 27 14:24:42 EDT 2007

Ideally, I should remove invalidPos and invalidSize from WindowEnsemble. 
However, I must then handle the case where callbacks lag more than one 
stack call of the target window.


normal
- stack1
- callback1
- stack2
- callback2
- stack3
- callback3

normal
- stack1
- stack2
- stack3
- callback1
- a revert stack call
- callback2
- a revert stack call
- callback3
- a revert stack call
- more callbacks from reverts


questions:
- do I need a count of callbacks to ignore.
    - resize and position callbacks can also possible coalesce, so counting
      exactly cannot be relied on
- but what about externally prompted callbacks?
    - how can I still process them?

An additional complications is that the GLUT callback for window size,
overwrites the 'possibly' new setting.  Eventually all callbacks are called.


The key question is how to distignuish callbacks prompted by multiwindow (thus
ignore) or prompted by external sources (thus should be processed for 
restacking).

- data structure
recentMoves[win] = [pos1, pos2, pos3]

def on_move(self, win, x, y):
    if (x, y) in self.recentMoves[win]:
        # remove everything up to pos (possible coalesence of events)
        # and ignore this callback
    else:
        # new callback from external source, should be processed
        
        if len(self.recentMoves[win]) == 0:
            # usually the recentMoves[win] will be empty
            # thus process this event with stacking
            self.stack(win)
        else:
            # but it could also be populated, 
            # in which case we have backed up callbacks
            # leave recentMoves alone and continue to ignore those events as
            # they come in.
            self.stack(win)

What is the effect of external prompted callbacks that HAPPEN to match locally
prompted callbacks


normal:
    set A
        recent = [A]
        GLUT buffer = [A]
    set B
        recent = [A, B]
        GLUT buffer = [A, B]        
    callback A
        recent = [B]
        GLUT buffer = [B]        
    callback B
        recent = []
        GLUT buffer = []

my example1:
    set A
        recent = [A]
        GLUT buffer = [A]
    set B
        recent = [A, B]
        GLUT buffer = [A, B]        
    external set A'
        GLUT buffer = [A, B, A']
    callback A
        recent = [B]
        GLUT buffer = [B, A']
    callback B
        recent = []
        GLUT buffer = [A']
    callback A'
        process A'
This is correct


my example2:
    external set B'
        GLUT buffer = [B']
    set A
        recent = [A]
        GLUT buffer = [B',A]
    set B
        recent = [A, B]
        GLUT buffer = [B', A, B]        
    callback B'
        - B' in recent
        - ignore up to B in recent (assume coalescence)
        recent = []
        GLUT buffer = [A, B]
        
    callback A
        process A
    
        set A
            recent = [A]
            GLUT buffer = [B, A]
            
    callback B
        recent = [A]
        GLUT buffer = [A]
    
        - B not in recent
        - treat as new movement
        process B
        
        set B
            recent = [A, B]
            GLUT buffer = [A, B]
        
    callback A
        recent = [B]
        GLUT buffer = [B]
    
    callback B
        recent = []
        GLUT buffer = []
        

A small jitter but should end on the correct state.





=============================================================================
Tue Sep 18 00:17:47 EDT 2007

# how to compile summon on windows
pythonw setup-windows.py bdist_wininst build --compiler=mingw32


- remember! python cannot block waiting for SUMMON, if we are in a function call 
from SUMMON.  Otherwise it is a deadlock!

- make (x,y) from win.set_position(x, y) become immediately visible from 
  win.get_position()
- make (w,h) from win.set_size(w, h) become immediately visible from 
  win.get_size()



==============================================================================
Tue Sep 11 21:12:44 EDT 2007

- svg has bugs, fix them
- mouse motion in opening window bug. DONE
- added RemoveElement bug DONE
- added win.raise_window(True) DONE
    - make window ensembles raise together
- glut menus DONE
    win.set_menu_binding('left'|'middle'|'right', ['alt' | 'ctrl' | 'shift'])
    win.set_menu(menu)


class Menu:
    def __init__(self):
        self.menuid = summon_core.new_menu()
    
    def __del__(self):
        summon_core.del_menu(self.menuid)

    def add_entry(self, text, func):
        summon_core.add_menu_entry(self.menuid, text, func)
    
    def add_submenu(self, submenu):
        summon_core.add_submenu(self.menuid, submenu.menuid)
    
    def remove(self, index):
        summon_core.remove_menu_item(self.menuid, index)
    
    


=============================================================================
Sun Sep  9 18:59:40 EDT 2007

- add zoom_clamp
    zoom_clamp(minx=0, miny=0, maxx=None, maxy=None, clip=False, *elements)
    
    zoom_clamp(1, 1, 10, 10, True, group(...), group(...))
    

- get_bounding for SVG
- add drag and select
- fix SVG text_clip


- add aGroup.get_parent() DONE
- use ref counts for element parent child relationships. DONE
- track down close view bug DONE

#=============================================================================

move more of the Model functions to Elements

model.add_group
model.insert_group
    g.append(aGroup)
    g.extend(*groups)

mode.remove_group
    g.remove(aGroup)

model.get_bounding()
    g.get_bounding()

model.show_group(True)
    g.show(True)






#=============================================================================
; transforms
(translate x y z  . groups)
(rotate x y z r . groups)
(scale x y z . groups)

; poly primitives
(triangles  . vertex|color)
(quads  . vertex|color)
(lines . vertex|color)

; basic primitives
(vertex x y z)
(color r g b a)

; hotspots
(hotspot-radius x y radis func-on func-out)
(hotspot-rect x1 y1 x2 y2 func-on func-out)

; drawing grouping, can be flattened
;   may not be needed if all drawing is actually kept in draw lists
;   draw lists do the "flattening"
(block . primitives)

; dynamic drawing
(dynamic-block func)

; group creation
(group . contents)

; gateway functions
(add-group . groups)
(change-group group-id group)
(insert-group group-id pos . groups)


- drawlist can be made between every dynamic code, auto-generated drawlists
    would be nice.
- hotspot locations can calculated from keeping track of enclosing transforms
- hotspots within dynamics need to be removed on every frame


- internal structures
    - model
        - root group id
        - group hashtable
        - hotspot quadtree

list --> [gateway] --> structures

class Group {
    List elements = { groupid, drawlist, dynamic-code };
    List hotspots;
}


convert list to structures

Element *Convert(SCM lst) {
    Element *element;
    
    switch (item.first) {
        case "group":
            element = new Group();
            
            for item in list: {
                elm = Convert(item);
                
                switch (elm.type) {
                    case dynamic:
                        startNewDrawList;
                    case hotspot:
                        element.hotspots.add(elm);
                }
                
                element.elements.add(elm);
            }

        case "dynamic":
            element = new DynamicDraw(lst.second); // pointer to lambda
        case "hotspot":
            element = new Hotspot(lst.second ...); // populate with lst fields
        case "triangles":
            glBegin(GL_TRIANGLES);
            
            for item in list: {
                elm = Convert(item);
                
                switch (elm.type) {
                    case dynamic:
                        startNewDrawList;
                    case hotspot:
                        element.hotspots.add(elm);
                }
                
                element.elements.add(elm);
            }
            
            glEnd();
            element = NULL; // nothing to return for pure drawing
    }
    
    return element;
}



- Window Controllers
   - Inputs are a fixed vocabularly
      - click
         - (button, x, y)
      - drag
         - (button, vx, vy)
      - wheel
         - (direction)         
      - key
         - (key, modifiers)

   - Inputs are mapped by Binding to Commands
      - Commands are then sent to either View or Model
   - each Window Controller owns a binding

- Window Views
   - implement Window Commands
      - needs ability to inherit Command Set from other classes
      - needs ability to register new Commands

- Models
   - implement Model Commands
      - needs ability to inherit Command Set from other classes
      - needs ability to register new Commands

- Command Registry


(bind mouse-left-drag translate)

input --[binding]--> command --[command router]--> action

controller {
    cmd = binding.GetDragCommand(button, vx, vy)
    ExecCommand(cmd)
    
    ...
    ExecCommand(cmd) {
        switch cmd.GetId():
            case CMD_TRANSLATE: view.ExecCommand(cmd)
            case CMD_EDIT_MATRIX: mat.ExecCommand(cmd)
    }
}
