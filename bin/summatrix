#!/usr/bin/env python-i
#
# SUMMATRIX (SUMMON Sparse Matrix Viewer)
#
# Example of using summon to visualize large sparse matrices.
#
# Example matrices are in summon/examples/summatrix/
# Matrix file formats:
#   *.mat   compress row (-r option)
#   *.imat  index matrix (-i option)
#   *.lmat  label matrix (-l option)
#   *.mat   dense matrix (-d option)
#

# TODO: implement find, and marking


# python libs
import random
import sys

# summon libs
import summon
from summon.core import *
from summon import shapes, util, treelib
from summon import matrix
from summon import sumtree


def parseColor(colorstr):
    """Parse <r>,<g>,<b> into a list of three floats"""
    return map(float, colorstr.split(','))

def parseSize(sizestr):
    """Parse <width>x<hieght> into a list of two ints"""
    return map(int, sizestr.split('x'))


# command line options
options = [
    "Matrix input formats",
    ["r:", "rmat=", "comprow", "<compressed row matrix file>",
        {"single": True,
         "help": "load a compressed row matrix file (*.mat)"}],
    ["i:", "imat=", "imat", "<index matrix file>",
        {"single": True,
         "help": "load a index matrix file (*.imat)"}],
    ["l:", "lmat=", "lmat", "<labeled sparse matrix file>",
        {"single": True,
         "help": "load a labeled matrix file (*.lmat)"}],
    ["d:", "dense=", "dense", "<dense matrix file>",
        {"single": True,
         "help": "load a dense matrix file (*.mat)"}],
    
    "Labels",
    ["", "rlab=", "rowlabels", "<row labels>",
        {"single": True}],
    ["", "clab=", "collabels", "<col labels>", 
        {"single": True}],    
    ["", "rclab=", "rowcollabels", "<row & col labels>", 
        {"single": True}],
    
    "Permutation",
    ["R:", "rperm=", "rperm", "<row permutation>",
        {"single": True}],
    ["C:", "cperm=", "cperm", "<col permutation>",
        {"single": True}],
    ["B:", "rcperm=", "rcperm", "<row & col permutation>",
        {"single": True}],
    
    ["o:", "order=", "order", "<label order>",
        {"single": True,
         "help": "only used with label matrix"}],
    
    "Clustering",
    ["", "rpart=", "rpart", "<row partition ids>",
        {"single": True}],
    ["", "cpart=", "cpart", "<col partition ids>",
        {"single": True}],
    ["", "rcpart=", "rcpart", "<row & col partition ids>",
        {"single": True}],

    "Trees",
    ["", "rptree=", "rptree", "<row parent tree file>",
        {"single": True}],
    ["", "cptree=", "cptree", "<column parent tree file>",
        {"single": True}],
    ["", "rtree=", "rtree", "<row tree newick file>",
        {"single": True}],
    ["", "ctree=", "ctree", "<column tree newick file>",
        {"single": True}],
    ["", "treelens", "treelens", "",
        {"single": True,
         "help": "use branch lengths in tree files"}],         
    
    "Display",
    ["L:", "showlabels=", "showlabels", "(inline,panels,none)",
        {"single": True,
         "default": "inline"}],
    ["c:", "color=", "color", "(solid|posneg|rainbow|filename)",
        {"single": True,
         "default": "rainbow",
         "help": "specify a colormap using a predefined map or " +
                 "a custom map from a file"}],
    ["", "bgcolor=", "bgcolor", "r,g,b",
        {"single": True,
         "parser": parseColor,
         "default": (0,0,0),
         "help": "specify the background color (default: black)\n"+
                 "    Each value is between 0 and 1."}],
    ["", "drawzeros", "drawzeros", "",
        {"single": True,
         "help": "a bool whether to explicitly draw zeros with the colormap"}],
    ["", "style=", "style", "(points|quads)",
        {"single": True,
         "default": "points",
         "help": "draw non-zeros using points (default) or quadrilaterals"}],
    ["", "winsize=", "winsize", "<width>x<height>",
        {"single": True,
         "default": (400, 400),
         "parser": parseSize,
         "help": "specify initial window size (default: 400x400)"}],
    
    "Sampling",
    ["s:", "sample=", "sample", "<sample fraction>",
        {"single": True,
         "parser": float,
         "help": "choose a random subset of non-zeros to display (only for sparse matrices)"}],
    ["", "rsample=", "rsample", "<sample fraction>",
        {"single": True,
         "parser": float,
         "help": "choose a random subset of rows to display"}],
    ["", "csample=", "csample", "<sample fraction>",
        {"single": True,
         "parser": float,
         "help": "choose a random subset of columns to display"}],
    
    "Miscellaneous",
    ["", "cutoff=", "cutoff", "<value>",
        {"default": -util.INF,
         "parser": float,
         "single": True,
         "help": "if specified, only loads values greater than 'cutoff'"}],             
    ["", "loadvals", "loadvals", "",
        {"single": True,
         "help": "load all non-zeros into memory for easy interactive display"}]
]


conf = util.parseOptions(sys.argv, options, resthelp="<python script>")



#=============================================================================
# Main Execution
#

print "SUMMATRIX (SUMMON Matrix Visualizer)"
print "Matt Rasmussen 2005-2007"
print

mat = matrix.Matrix()

# read permutations
if "rperm" in conf:
    mat.rperm = util.readInts(conf["rperm"])
if "cperm" in conf:
    mat.cperm = util.readInts(conf["cperm"])
if "rcperm" in conf:
    mat.rperm = util.readInts(conf["rcperm"])        
    mat.cperm = util.readInts(conf["rcperm"])

# read color
if conf["color"] == "posneg":
    mat.colormap = summon.PosNegColorMap()
elif conf["color"] == "rainbow":
    mat.colormap = summon.RainbowColorMap()
elif conf["color"] == "solid":
    mat.colormap = summon.SolidColorMap()
else:
    mat.colormap = summon.readColorMap(conf["color"])


if "order" in conf:
    mat.order = conf["order"]


# read matrix
matfile = "summatrix"
if "comprow" in conf:
    matrix.openCompRow(conf["comprow"], mat, 
                loadvals=conf.get("loadvals", False),
                sample=conf.get("sample", False),
                rowsample=conf.get("rsample", False),
                colsample=conf.get("csample", False),
                )
    matfile = conf["comprow"]
    
elif "imat" in conf:
    matrix.openImat(conf["imat"], mat, 
             loadvals=conf.get("loadvals", False),
             sample=conf.get("sample", False),
             rowsample=conf.get("rsample", False),
             colsample=conf.get("csample", False))
    matfile = conf["imat"]
    
elif "lmat" in conf:
    if "order" in conf:
        matrix.openLabeledMatrix(conf["lmat"], mat,
                          rowsample=conf.get("rsample", False),
                          colsample=conf.get("csample", False))
    else:
        matrix.openLabeledMatrix(conf["lmat"], mat,
                          rowsample=conf.get("rsample", False),
                          colsample=conf.get("csample", False))
    matfile = conf["lmat"]
    
elif "dense" in conf:
    matrix.openDense(conf["dense"], mat, 
              cutoff=conf["cutoff"],
              rowsample=conf.get("rsample", False),
              colsample=conf.get("csample", False))
    matfile = conf["dense"]
    
else:
    raise Exception("no matrix specified")


# read labels
if "rowlabels" in conf:
    mat.rowlabels = util.readStrings(conf["rowlabels"])
if "collabels" in conf:
    mat.collabels = util.readStrings(conf["collabels"])
if "rowcollabels" in conf:
    mat.rowlabels = util.readStrings(conf["rowcollabels"])
    mat.collabels = mat.rowlabels


# read partitions
if "rpart" in conf:
    mat.rpart = util.readStrings(conf["rpart"])
if "cpart" in conf:
    mat.cpart = util.readStrings(conf["cpart"])
if "rcpart" in conf:
    mat.rpart = util.readStrings(conf["rcpart"])
    mat.cpart = mat.rpart 

# setup default permutation from cluster ids
if mat.rpart and not mat.rperm:
    mat.rperm = range(len(mat.rpart))
    mat.rperm.sort(key=lambda x: mat.rpart[x])
    mat.rinv = util.invPerm(mat.rperm)
if mat.cpart and not mat.cperm:
    mat.cperm = range(len(mat.cpart))
    mat.cperm.sort(key=lambda x: mat.cpart[x])
    mat.cinv = util.invPerm(mat.cperm)

# modify permutations if row/col sampling is choosen
if len(mat.rshow) < mat.nrows or len(mat.cshow) < mat.ncols:
    mat = mat.submatrix(util.sort(mat.rshow), util.sort(mat.cshow))


# read trees
rtree = None
ctree = None
if "rptree" in conf:
    rtree = treelib.Tree()
    rtree.readParentTree(conf["rptree"], labels=mat.rowlabels)
if "cptree" in conf:
    ctree = treelib.Tree()
    ctree.readParentTree(conf["cptree"], labels=mat.collabels)
if "rtree" in conf:
    rtree = treelib.Tree()
    rtree.readNewick(conf["rtree"])
if "ctree" in conf:
    ctree = treelib.Tree()
    ctree.readNewick(conf["ctree"])

if rtree:
    leaves = rtree.leafNames()
    if mat.rowlabels == None:
        mat.rperm = map(int, leaves)
    else:
        lookup = util.list2lookup(mat.rowlabels)
        mat.rperm = util.mget(lookup, leaves)
    mat.rinv = util.invPerm(mat.rperm)
if ctree:
    leaves = ctree.leafNames()
    if mat.collabels == None:
        mat.cperm = map(int, leaves)
    else:
        lookup = util.list2lookup(mat.collabels)
        mat.cperm = util.mget(lookup, leaves)
    mat.cinv = util.invPerm(mat.cperm)


# determine label settings
if conf["showlabels"] == "inline":
    showLabels = True
    showLabelWindows = False
elif conf["showlabels"] == "panels":
    showLabels = True
    showLabelWindows = True
elif conf["showlabels"] == "none":
    showLabels = False
    showLabelWindows = False
else:
    raise Exception("unknown showlabels setting '%s'" % conf["showlabels"])

# execute python scripts
for script in conf["REST"]:
    print "executing", script
    execfile(script)


# create matrix viewer and display it
viewer = matrix.MatrixViewer(mat, bgcolor=conf["bgcolor"], 
                            drawzeros=conf["drawzeros"], 
                            style=conf["style"],
                            showLabels=showLabels,
                            showLabelWindows=showLabelWindows,
                            winsize=conf["winsize"],
                            title=matfile,
                            rtree=rtree,
                            ctree=ctree,
                            useTreeLens=(conf["treelens"], conf["treelens"]))
util.tic("drawing matrix")
viewer.show()
util.toc()

#if rtree:
#    layout = treelib.layoutTreeHierarchical(rtree, 1, -1)
#    treevis = sumtree.SumTree(rtree, name="row tree", xscale=0, layout=layout)
#    treevis.show()
