#!/usr/bin/env summon
#
# SUMMATRIX (SUMMON Sparse Matrix Viewer)
#
# Example of using summon to visualize large sparse matrices.
#
# Example matrices are in summon/examples/summatrix/
# Matrix file formats:
#   *.mat   compress row (-r option)
#   *.imat  index matrix (-i option)
#   *.lmat  label matrix 
#

import random
import sys

from summon import *
from summonlib import shapes, util

# command line options
options = [
    ["r:", "comprow=", "comprow", "AUTO<compressed row matrix file>"],
    ["i:", "imat=", "imat", "AUTO<index matrix file>"],
    ["l:", "lmat=", "lmat", "AUTO<labeled sparse matrix file>"],
    ["d:", "dense=", "dense", "AUTO<dense matrix file>"],
    
    ["o:", "order=", "order", "AUTO<label order>"],
    
    ["R:", "rperm=", "rperm", "AUTO<row permutation>"],
    ["C:", "cperm=", "cperm", "AUTO<col permutation>"],
    ["B:", "rcperm=", "rcperm", "AUTO<row & col permutation>"],
   
    ["s:", "sample=", "sample", "AUTO<sample fraction>"],
    ["c:", "color=", "color", "AUTO(solid|posneg|rainbow)"]
]

try:
    param, rest = util.parseArgs(sys.argv[1:], options, "files")
except:
    sys.exit(1)



#############################################################################
# Data Structures
#

class RainbowColorMap:
    def __init__(self, maxv=1.0, minv=0.0):
        self.max = maxv
        self.min = minv
        self.range = maxv - minv
    
    def get(self, val):
        x = (val - self.min) / self.range
        return [-2 + 4*x, 2 - 4*abs(.5-x), 2 - 4*x]
    

class PosNegColorMap:
    def __init__(self, minv=-1.0, maxv=1.0):
        self.max = maxv
        self.min = minv
    
    def get(self, val):
        if val >= 0:
            return [1, 0, 0, val/self.max]
        else:
            return [0, 1, 0, val/self.min]


class Matrix (util.Dict):
    def __init__(self):
        util.Dict.__init__(self, 2, 0)
        self.nrows = 0
        self.ncols = 0
        self.nnz   = 0
        
        self.order = None
        self.maxval = None
        self.minval = None
        
        self.rperm = []
        self.cperm = []
        self.rinv  = []
        self.cinv  = []
        
        self.colormap = PosNegColorMap()
        self.rows = []
        self.cols = []
        self.vals = []
            
    
    def setup(self, nrows, ncols, nnz):
        self.nrows = nrows
        self.ncols = ncols
        self.nnz   = nnz        

        if self.rperm == []:
            self.rperm[:] = range(nrows)
        if self.cperm == []:
            self.cperm[:] = range(ncols)

        self.rinv[:] = util.invPerm(self.rperm)
        self.cinv[:] = util.invPerm(self.cperm)

    def setColor(colormap, low, top):
        self.colormin = float(low)
        self.colormax = float(top)
        self.colorrange = float(top - low)
        self.colormap = colormap
        self.colorlen = colorlen
        

    def getColor(self, val):
        i = int((val - self.colormin) / self.colorrange)
        i = min(max(i, 0), self.colorlen)
        return self.colormap[i]


#############################################################################
# Matrix Reading
#


def openCompRow(filename, mat):
    util.tic("reading '%s'" % filename)
    infile = file(filename)
    
    # read header
    fields = infile.next().split()
    if len(fields) == 2:
        (nrows, nnz) = map(int, fields)
        ncols = nrows
    elif len(fields) == 3:
        (nrows, ncols, nnz) = map(int, fields)
    else:
        raise "expected (nrows, nnz) or (nrows, ncols, nnz) in first line"
    
    
    util.log("%s: %d nrows, %d ncols, %d non-zeros" % (filename, nrows, ncols, nnz))
    
    mat.setup(nrows, ncols, nnz)
    rows, cols, vals = (mat.rows, mat.cols, mat.vals)
        
    row = 0
    maxval = -1e1000
    minval = 1e1000
    for line in infile:
        fields = line.split()

        if "sample" in param and random.random() > param["sample"]:
            row += 1
            continue

        for i in xrange(0, len(fields), 2):
            col = int(fields[i]) - 1
            val = float(fields[i+1])
            rows.append(row)
            cols.append(col)
            vals.append(val)
            if val > maxval: maxval = val
            if val < minval: minval = val
        row += 1
    util.toc()
    
    mat.maxval = maxval
    mat.minval = minval
    
    return mat


def openImat(filename, mat):
    util.tic("reading '%s'" % filename)
    infile = file(filename)
    
    # read header
    (nrows, ncols, nnz) = map(int, infile.next().split())
    print "%s: %d nrows, %d ncols, %d non-zeros" % (filename, nrows, ncols, nnz)        
    
    mat.setup(nrows, ncols, nnz)
    rows, cols, vals = (mat.rows, mat.cols, mat.vals)
    
    i = 0
    maxval = -1e1000
    minval = 1e1000
    for line in infile:
        if "sample" in param and random.random() > param["sample"]:
            continue
        
        (row, col, val) = line.split()
        score = float(val)
        rows.append(int(row))
        cols.append(int(col))
        vals.append(score)
        if score > maxval: maxval = score
        if score < minval: minval = score
    util.toc()
    
    mat.maxval = maxval
    mat.minval = minval
    
    return mat



def openLabeledMatrix(filename, mat):
    util.tic("reading '%s'" % filename)
    
    # read all data
    nnz = 0
    maxval = -1e1000
    minval = 1e1000
    for line in file(filename):
        tokens = line.split()
        score = float(tokens[2])
        mat[tokens[0]][tokens[1]] = score
        if score > maxval: maxval = score
        if score < minval: minval = score
        nnz += 1
    
    mat.maxval = maxval
    mat.minval = minval
    
    # determine order
    if mat.order != None:
        labels = util.readStrings(mat.order)
    else:
        set = {}
        for i in mat:
            set[i] = 1
            for j in mat[i]:
                set[j] = 1
        labels = util.uniq(set.keys())
        labels.sort()
    lookup = util.list2lookup(labels)
    
    mat.setup(len(labels), len(labels), nnz)
    rows, cols, vals = (mat.rows, mat.cols, mat.vals)
    
    # store data
    for i in mat:
        for j in mat[i]:
            rows.append(lookup[i])
            cols.append(lookup[j])
            vals.append(mat[i][j])
    
    util.toc()
    
    return mat
    


def openDense(filename, mat):
    util.tic("reading '%s'" % filename)
    infile = file(filename)
    
    # read header
    (nrows, ncols) = map(int, infile.next().split())
    nnz = nrows * ncols
    util.log("%s: %d nrows, %d ncols, %d non-zeros" % (filename, nrows, ncols, nnz))
    
    mat.setup(nrows, ncols, nnz)
    rows, cols, vals = (mat.rows, mat.cols, mat.vals)
    
    # read in whole matrix
    maxval = -1e1000
    minval = 1e1000
    r = 0
    for line in infile:
        entries = map(float, line.split())
        for c in xrange(len(entries)):
            rows.append(r)
            cols.append(c)
            vals.append(entries[c])
            if entries[c] > maxval: maxval = entries[c]
            if entries[c] < minval: minval = entries[c]
        r += 1
    
    mat.maxval = maxval
    mat.minval = minval
        
    util.toc()
    return mat



#######################################################################
# Drawing
#

def drawBorder(nrows, ncols):
    # draw boundary 
    add_group(group(color(1,1,1), 
              shapes.boxStroke(-.5,.5,ncols-.5, -nrows+.5)))
    
def drawMatrix(mat):
    util.tic("drawing matrix")
    mat.colormap.max = mat.maxval
    mat.colormap.min = mat.minval
    getcolor = mat.colormap.get
    vis = []
    chunksize = 1000
    rows, cols, vals = (mat.rows, mat.cols, mat.vals)
    rinv, cinv = (mat.rinv, mat.cinv)
    
    for chunk in xrange(0, len(rows), chunksize):
        if param["color"][-1] == "solid":
            for k in xrange(chunk, min(len(rows), chunk+chunksize)):
                vis.append(cinv[cols[k]])
                vis.append(-rinv[rows[k]])
        else:
            for k in xrange(chunk, min(len(rows), chunk+chunksize)):
                vis.append(color(* getcolor(vals[k])))
                vis.append(cinv[cols[k]])
                vis.append(-rinv[rows[k]])
        add_group(group(points(* vis)))
        vis = []
    
    util.toc()
    


#######################################################################
# Main Execution
#

print "SUMMATRIX (SUMMON Matrix Visualizer)"
print "Matt Rasmussen 2005"
print

set_antialias(False)
mat = Matrix()


# read permutations
if "rperm" in param:
    mat.rperm = util.readInts(param["rperm"][-1])
elif "cperm" in param:
    mat.cperm = util.readInts(param["cperm"][-1])
elif "rcperm" in param:
    mat.rperm = util.readInts(param["rcperm"][-1])        
    mat.cperm = util.readInts(param["rcperm"][-1])

# read color
param.setdefault("color", ["solid"])
if param["color"][-1] == "posneg":
    mat.colormap = PosNegColorMap()
elif param["color"][-1] == "rainbow":
    mat.colormap = RainbowColorMap()


if "order" in param:
    mat.order = param["order"][-1]

# read matrix
if "comprow" in param:
    openCompRow(param["comprow"][-1], mat)
elif "imat" in param:
    openImat(param["imat"][-1], mat)
elif "lmat" in param:
    if "order" in param:
        openLabeledMatrix(param["lmat"][-1], mat)
    else:
        openLabeledMatrix(param["lmat"][-1], mat)
elif "dense" in param:
    openDense(param["dense"][-1], mat)
else:
    raise "no matrix specified"


drawMatrix(mat)
drawBorder(mat.nrows, mat.ncols)
home()


