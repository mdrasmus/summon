Tue Sep 18 00:17:47 EDT 2007

# how to compile summon on windows
pythonw setup-windows.py bdist_wininst build --compiler=mingw32


==============================================================================
Tue Sep 11 21:12:44 EDT 2007

- svg has bugs, fix them
- mouse motion in opening window bug. DONE
- added RemoveElement bug DONE
- added win.raise_window(True) DONE
    - make window ensembles raise together
- glut menus DONE
    win.set_menu_binding('left'|'middle'|'right', ['alt' | 'ctrl' | 'shift'])
    win.set_menu(menu)


class Menu:
    def __init__(self):
        self.menuid = summon_core.new_menu()
    
    def __del__(self):
        summon_core.del_menu(self.menuid)

    def add_entry(self, text, func):
        summon_core.add_menu_entry(self.menuid, text, func)
    
    def add_submenu(self, submenu):
        summon_core.add_submenu(self.menuid, submenu.menuid)
    
    def remove(self, index):
        summon_core.remove_menu_item(self.menuid, index)
    
    


=============================================================================
Sun Sep  9 18:59:40 EDT 2007

- add zoom_clamp
    zoom_clamp(minx=0, miny=0, maxx=None, maxy=None, clip=False, *elements)
    
    zoom_clamp(1, 1, 10, 10, True, group(...), group(...))
    

- get_bounding for SVG
- add drag and select
- fix SVG text_clip


- add aGroup.get_parent() DONE
- use ref counts for element parent child relationships. DONE
- track down close view bug DONE

#=============================================================================

move more of the Model functions to Elements

model.add_group
model.insert_group
    g.append(aGroup)
    g.extend(*groups)

mode.remove_group
    g.remove(aGroup)

model.get_bounding()
    g.get_bounding()

model.show_group(True)
    g.show(True)






#=============================================================================
; transforms
(translate x y z  . groups)
(rotate x y z r . groups)
(scale x y z . groups)

; poly primitives
(triangles  . vertex|color)
(quads  . vertex|color)
(lines . vertex|color)

; basic primitives
(vertex x y z)
(color r g b a)

; hotspots
(hotspot-radius x y radis func-on func-out)
(hotspot-rect x1 y1 x2 y2 func-on func-out)

; drawing grouping, can be flattened
;   may not be needed if all drawing is actually kept in draw lists
;   draw lists do the "flattening"
(block . primitives)

; dynamic drawing
(dynamic-block func)

; group creation
(group . contents)

; gateway functions
(add-group . groups)
(change-group group-id group)
(insert-group group-id pos . groups)


- drawlist can be made between every dynamic code, auto-generated drawlists
    would be nice.
- hotspot locations can calculated from keeping track of enclosing transforms
- hotspots within dynamics need to be removed on every frame


- internal structures
    - model
        - root group id
        - group hashtable
        - hotspot quadtree

list --> [gateway] --> structures

class Group {
    List elements = { groupid, drawlist, dynamic-code };
    List hotspots;
}


convert list to structures

Element *Convert(SCM lst) {
    Element *element;
    
    switch (item.first) {
        case "group":
            element = new Group();
            
            for item in list: {
                elm = Convert(item);
                
                switch (elm.type) {
                    case dynamic:
                        startNewDrawList;
                    case hotspot:
                        element.hotspots.add(elm);
                }
                
                element.elements.add(elm);
            }

        case "dynamic":
            element = new DynamicDraw(lst.second); // pointer to lambda
        case "hotspot":
            element = new Hotspot(lst.second ...); // populate with lst fields
        case "triangles":
            glBegin(GL_TRIANGLES);
            
            for item in list: {
                elm = Convert(item);
                
                switch (elm.type) {
                    case dynamic:
                        startNewDrawList;
                    case hotspot:
                        element.hotspots.add(elm);
                }
                
                element.elements.add(elm);
            }
            
            glEnd();
            element = NULL; // nothing to return for pure drawing
    }
    
    return element;
}



- Window Controllers
   - Inputs are a fixed vocabularly
      - click
         - (button, x, y)
      - drag
         - (button, vx, vy)
      - wheel
         - (direction)         
      - key
         - (key, modifiers)

   - Inputs are mapped by Binding to Commands
      - Commands are then sent to either View or Model
   - each Window Controller owns a binding

- Window Views
   - implement Window Commands
      - needs ability to inherit Command Set from other classes
      - needs ability to register new Commands

- Models
   - implement Model Commands
      - needs ability to inherit Command Set from other classes
      - needs ability to register new Commands

- Command Registry


(bind mouse-left-drag translate)

input --[binding]--> command --[command router]--> action

controller {
    cmd = binding.GetDragCommand(button, vx, vy)
    ExecCommand(cmd)
    
    ...
    ExecCommand(cmd) {
        switch cmd.GetId():
            case CMD_TRANSLATE: view.ExecCommand(cmd)
            case CMD_EDIT_MATRIX: mat.ExecCommand(cmd)
    }
}
